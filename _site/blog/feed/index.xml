<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>rafekettler.com</title>
    <link>http://www.rafekettler.com/blog</link>
    <description>My thoughts on programming and technology</description>
    <pubDate>Fri, 25 Feb 2011 05:20:31 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>C resources that helped me</title>
      <link>http://www.rafekettler.com/blog/2011/02/18/c-resources-that-helped-me</link>
      <pubDate>Fri, 18 Feb 2011 04:17:37 EST</pubDate>
      <category><![CDATA[Uncategorized]]></category>
      <guid>http://rafekettler.com/?p=301</guid>
      <description>C resources that helped me</description>
      <content:encoded><![CDATA[<p>I've been picking up C a bit more lately, and it's been great so far. Along the way, I've picked up some great articles, books, and sites. I thought I'd post them for posterity and the convenience of anyone who might happen on this.</p>
<ul>
<li><a href="http://cslibrary.stanford.edu/101/EssentialC.pdf">The Essential C, by Nick Parlante</a> -- This is really a must for anyone who wants to relearn C or an experienced programmer who want a primer. It's only 50 pages, and it's quick and to the point. It's something that you could read and comprehend in a day if you wanted to. It's also very thorough -- most of the major language concepts see some coverage.</li>
<li><a href="http://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628">K&amp;R C, by Kernighan and Ritchie</a> -- no C programmer would be complete without it. If you have to ask, you shouldn't be using C.</li>
<li><a href="http://c-faq.com/">comp.lang.c FAQ</a> -- it's a great FAQ. Quite thorough. Even if you don't have a specific question, it's very educational to peruse: you can pick up nice bits and pieces of advice along the way.</li>
<li><a href="http://www.jetcafe.org/jim/highlowc.html">High and Low Level C by Jim Larson</a> -- sort of a guide to doing things in C that it wasn't really designed to do (closures, classes, GC), and sort of a guide to low level hacks. It's a good overview of some cool hacks in C that can come in handy for the advanced C coder.</li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG14/">The ISO C standard</a> -- again, if you have to ask...</li>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.5.2/gcc.pdf">The GCC manual</a> -- everyone's favorite C compiler has quite a few options and quite a few associated tricks. Also, GNU C is, in many ways, a superset of C itself -- it allows a number of things that the standard does not (like nested functions). It's nice to know what those features are.</li>
<li><a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/secure.html">The FreeBSD handbook's section on secure programming</a> -- programming in C, especially with strings, can be dangerous. This is the most comprehensive guide to programming securely that I've found so far.</li>
</ul>
<p>If I come across any other good resources, I'll add them.</p>]]></content:encoded>
    </item>
    <item>
      <title>Functional Programming in Python on Trial</title>
      <link>http://www.rafekettler.com/blog/2011/02/06/functional-programming-in-python-on-trial</link>
      <pubDate>Sun, 06 Feb 2011 04:55:56 EST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Programming]]></category>
      <guid>http://rafekettler.com/?p=283</guid>
      <description>Functional Programming in Python on Trial</description>
      <content:encoded><![CDATA[<p>Anyone who's in the know about Python knows quite a bit about what Guido likes about Python and what he doesn't. Something that he's been very clear about for a number of years is that he doesn't like some of the functional programming constructs in Python. I'm talking about lambda expressions, <code>map()</code>, <code>filter()</code>, and <code>reduce()</code>. He said in 2005 (when he was first envisioning Python 3):</p>
<blockquote>
<p>About 12 years ago, Python aquired lambda, reduce(), filter() and map(), courtesy of (I believe) a Lisp hacker who missed them and submitted working patches. But, despite the PR value, I think these features should be cut from Python 3000. </p>
</blockquote>
<p>Ultimately, lambda, map, and filter stayed as builtins, and reduce got moved to functools. But why all the fuss? You might want to read <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">the BDFL's article on the matter</a>. For those who want a bit of a different perspective, read on.</p>
<h3>Indictment</h3>
<p>Arguably, the big problem with functional programming constructs like lambdas and map is that they are less readable than their counterparts. Most would argue that <code>[x for x in y if x &gt; 2]</code> is more readable than <code>filter(lambda x: x &gt; 2, y]</code>. I won't argue with that. But that's certainly an extreme example, isn't it? It just so happens that this example represents a case that works out very nicely in a list comprehension. In the spirit of due process, however, this and other affronts to readability serve as sufficient evidence to charge functional constructs in Python with a quite heinous crime in the Python userland: obfuscation.</p>
<h3>On the charges against lambdas</h3>
<p>First, lambda expressions. This is a feature that should not be used to produce any substantial routine. I think most of us can agree that this is evil:</p>
<div class="pygments_tango"><pre><span class="n">x</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

<p>This is bad for a number of reasons:</p>
<ol>
<li>No way to write a docstring</li>
<li>No normal function declaration -- hangs up documentation tools, makes it hard to know that function x exists by reading the source</li>
<li>One-liner (in the bad way) -- there's quite a bit going on for that one line of code</li>
</ol>
<p>Rather, it should always be written in its normal form, like so:</p>
<div class="pygments_tango"><pre><span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;I provide useful info about the function for IDEs and docs generators.</span>
<span class="sd">    I also am good for those reading source.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

<p>Wasn't that better? Clearly, lambda must be guilty of the crime of obfuscation.</p>
<p>Now to sentencing: what should we do to lambda? Many would suggest to get rid of it. I say keep it. It might be obscure and unreadable in some cases, but it's a lifesaver in cases where you need to pass a very simple callback to a function. So, in the case of <code>lambda v. Python</code>, the judge finds the defendant guilty and orders him to be placed in house arrest, only to leave when used as a simple callback.</p>
<h3>On the charges against map and filter</h3>
<p>map and filter face similar charges of obfuscation. Many would argue that powerful list comprehensions obviate the need for map and filter:</p>
<div class="pygments_tango"><pre><span class="nb">map</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span> <span class="c"># more clear, relies on more &quot;standard&quot; language constructs</span>
<span class="nb">filter</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">[</span><span class="n">x</span> <span class="k">for</span>  <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="c"># likewise</span>
</pre></div>

<p>Personally, I don't find the map and filter implementations to be much less readable than their list comprehension counterparts. However, I also happen to like functional programming and I know a good bit about Python. Most people would have a hard time reading this, especially as complexity increases.</p>
<p>Along the lines of "There should be one, and only one, obvious way to do it", map and filter are guilty of crowding Python with new solutions to problems that have already been solved. In the court of Python, this is an offense punishable by death. Because of this, in the case <code>map and filter v. Python</code>, the judge finds the defendants guilty and sentences them to death. The defendants should be promptly removed from the standard library, and should only leave their places on death row for code golf competitions.</p>
<h3>reduce</h3>
<p>reduce is a fold operation, if you're familiar with other functional languages you should get this. It's a recursive concept and a common idiom in functional programming that many languages encapsulated in a higher order function (as they should have). However, Python is not a very recursive language. To demonstrate to the court why reduce is guilty, take a look at this example.</p>
<div class="pygments_tango"><pre><span class="n">x</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span> <span class="c"># what is this i don&#39;t even</span>

<p><span class="c"># equivalent in human speak</span>
<span class="n">product</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
     <span class="n">product</span> <span class="o">*=</span> <span class="n">seq</span> <span class="c"># oh, we&#39;re just finding the product of a sequence</span>
</pre></div></p>
<p>GUILTY! In this case reduce only serves to dramatically reduce(geddit) the amount of code written at the expense of any clarity. This is a simple example and is, admittedly, quite understandable and simple for anyone who has used reduce  (or fold in another language). However, as code grows in complexity, loops are almost always more clear. So, in the case of <code>reduce v. Python</code>, the judge finds the defendant not only guilty of obfuscation and lack of necessity, but also guilty of pure evil. For that, reduce meets the gallows (as it essentially has in Python 3).</p>
<h3>Syllabus (AKA tl;dr)</h3>
<p><code>lambda</code> is only acceptable in a few restricted situations. <code>map</code>, <code>filter</code>, and <code>reduce</code> need to leave the Python language because they are unnecessary and they quickly grow unwieldy and unreadable as their complexity increases.</p>
<p>I accept functional programming as a good idea in general (what would we do without closures and first-class functions, after all), but some parts of Python are relics of Lisp hackers before us and don't really fit in with the language philosophy. Because of this, I'll take Guido's side: I don't like most of the functional programming stuff mixed into Python's global namespace and syntax. I don't mind having a module for it (<code>functools</code> is useful, and when you import it it's a clear statement of intent), in fact, I happen to like that module. But in general, higher-order functions and lambdas need to be relegated to a lower place in the language.</p>]]></content:encoded>
    </item>
    <item>
      <title>Magic Methods Guide is Complete</title>
      <link>http://www.rafekettler.com/blog/2011/01/24/magic-methods-guide-is-complete</link>
      <pubDate>Mon, 24 Jan 2011 23:26:57 EST</pubDate>
      <category><![CDATA[Uncategorized]]></category>
      <guid>http://rafekettler.com/?p=270</guid>
      <description>Magic Methods Guide is Complete</description>
      <content:encoded><![CDATA[<p>It's finally done (feature-complete, I mean). It still may have errors, but it works. Check it out <a href="http://www.rafekettler.com/magicmethods.html">here</a>.</p>]]></content:encoded>
    </item>
    <item>
      <title>The magic methods guide now has a github repo</title>
      <link>http://www.rafekettler.com/blog/2011/01/20/the-magic-methods-guide-now-has-a-github-repo</link>
      <pubDate>Thu, 20 Jan 2011 04:56:35 EST</pubDate>
      <category><![CDATA[Uncategorized]]></category>
      <guid>http://rafekettler.com/?p=264</guid>
      <description>The magic methods guide now has a github repo</description>
      <content:encoded><![CDATA[<p>Check out the github repo for the magic methods guide at http://www.github.com/RafeKettler/magicmethods. Maybe you could even try and find an issue?</p>]]></content:encoded>
    </item>
    <item>
      <title>Magic Method Monday: Mixed Mode Arithmetic</title>
      <link>http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic</link>
      <pubDate>Mon, 17 Jan 2011 17:11:15 EST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Programming]]></category>
      <category><![CDATA[Magic Method Monday]]></category>
      <guid>http://rafekettler.com/?p=261</guid>
      <description>Magic Method Monday: Mixed Mode Arithmetic</description>
      <content:encoded><![CDATA[<p>This may very well be the last magic methods blog post, and it's fitting that I'll be addressing a method that I initially overlooked.</p>
<p>Python would be very hard to use without mixed-mode arithmetic: imagine what Python would be like if a type-conversion was necessary to add an integer to a float. In order to make our classes behave the same way, we can define a <code>__coerce__</code> method.</p>
<p><code>__coerce__</code></p>
<p>Method to implement mixed mode arithmetic. Takes arguments <code>self</code> and <code>other</code>. Should return <code>None</code> if type conversion is impossible. Otherwise, it should return a pair (2-tuple) of self and other, manipulated to have the same type.</p>
<p>That's all for now; it seems that I'll have to find another weekly series to tackle. Keep watching the magic methods guide <a href="http://www.rafekettler.com/magicmethods.html">here</a>.</p>]]></content:encoded>
    </item>
    <item>
      <title>Magic Method Monday: Unicode and Nonzero</title>
      <link>http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero</link>
      <pubDate>Mon, 10 Jan 2011 17:18:43 EST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Programming]]></category>
      <category><![CDATA[Magic Method Monday]]></category>
      <guid>http://rafekettler.com/?p=256</guid>
      <description>Magic Method Monday: Unicode and Nonzero</description>
      <content:encoded><![CDATA[<p>We're nearing the end of the magic methods blog post series (and the beginning of the magic methods guide, which will be better organized, better explained, better demonstrated, and all in one place!). Thus, I'm running out of magic methods to work with. Here we head back to a few magic methods that I ignored (or forgot): <code>__unicode__</code> and <code>__nonzero__</code>.</p>
<p><code>__unicode__</code></p>
<p>Takes argument self. It returns a unicode string representation of the instance.</p>
<p><code>__nonzero__</code></p>
<p>Takes argument self and returns a boolean value, <code>True</code> or <code>False</code>. This method gets called when the <code>bool()</code> builtin is called on an instance, e.g.</p>
<div class="pygments_tango"><pre><span class="k">if</span> <span class="n">some_instance</span><span class="p">:</span>
    <span class="c">#do something</span>
</pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Follow the progress of the magic method guide</title>
      <link>http://www.rafekettler.com/blog/2011/01/06/follow-the-progress-of-the-magic-method-guide</link>
      <pubDate>Thu, 06 Jan 2011 23:35:28 EST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Programming]]></category>
      <guid>http://rafekettler.com/?p=252</guid>
      <description>Follow the progress of the magic method guide</description>
      <content:encoded><![CDATA[<p>I've uploaded a draft of the first few parts of the magic method guide. You can look at it <a href="http://www.rafekettler.com/magicmethods.html">here</a>.</p>
<p>Bear in mind, it's not nearly finished. I figured I'd post it in case someone wants to critique it, find some errors (I'm sure there will be some), or just follow the progress. Watch the version number as I add new content (I'm incrementing it by 1 each time I make a substantial addition, it'll be 1.0 by the time it's "content-complete").</p>]]></content:encoded>
    </item>
    <item>
      <title>Magic Method Monday: Context Managers</title>
      <link>http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers</link>
      <pubDate>Mon, 03 Jan 2011 05:25:06 EST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Programming]]></category>
      <category><![CDATA[Magic Method Monday]]></category>
      <guid>http://rafekettler.com/?p=235</guid>
      <description>Magic Method Monday: Context Managers</description>
      <content:encoded><![CDATA[<p>In Python 2.5, a new keyword was introduced in Python along with a new method for code reuse, the <code>with</code> statement. The concept of context managers was hardly new in Python (it was implemented before as a part of the library, I believe), but not until <a href="http://www.python.org/dev/peps/pep-0343/">PEP 343</a> was accepted did it achieve status as a first class language construct. Usage for the <code>with</code> statement is simple:</p>
<div class="pygments_tango"><pre><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
    <span class="c"># do something</span>
</pre></div>

<p>You're probably wondering what the point of all of this is. It might look innocuous at first, but there's some magic going on behind the scenes (and, as always with Python, you can take control of that magic for yourself).</p>
<p><code>__enter__</code></p>
<p>Defines what the context manager (the <code>with</code> statement) should do at the beginning of the block. It takes the argument <code>self</code>. Whatever it returns get bound to the <em>target</em> in the <code>with</code> statement (the name after <code>as</code>), so you could in fact use <code>__enter__</code> to create a completely new object altogether (if you'd like).</p>
<p><code>__exit__</code></p>
<p>Gets loaded at the start of the block and executed after the block. It can commonly be used to handle exceptions, perform cleanup (closing a file or connection), or do something that is always done immediately after we're finished with an object. Unlike <code>__enter__</code>, <code>__exit__</code> takes several arguments, <code>self</code>, <code>exception_type</code>, <code>exception_value</code>, and <code>traceback</code>. If there's no exception, the last 3 arguments will be <code>None</code>. Otherwise, you can either choose to handle the exception or let it get handled by the user; if you want to handle it, make sure <code>__exit__</code> returns <code>True</code> after all is said and done. Otherwise, let the exception happen.</p>]]></content:encoded>
    </item>
    <item>
      <title>Magic Methods Guide, Coming Up</title>
      <link>http://www.rafekettler.com/blog/2011/01/01/magic-methods-guide-coming-up</link>
      <pubDate>Sat, 01 Jan 2011 18:03:03 EST</pubDate>
      <category><![CDATA[Magic Method Monday]]></category>
      <guid>http://rafekettler.com/?p=233</guid>
      <description>Magic Methods Guide, Coming Up</description>
      <content:encoded><![CDATA[<p>Soon enough, I'll be creating an organized guide to Python's magic methods that will be more or less an aggregation of my blog posts on the matter, perhaps with a few more examples.</p>
<p>I'll at least make it available in HTML and PDF format, but I'm not sure where (I'm leaning towards creating a new subdomain to host it, but who knows). It will definitely be available from my blog, I'm just not sure if I want to jump through WordPress hoops to make the static content work right. I may just end up using plain HTML with a little embellishment (it'll also give me a great chance to use GeSHi manually, if I so choose).</p>
<p>Keep on the lookout for it, it should be coming in the next month or so (I have a few more weeks of Magic Method Monday blog posts before I run out of methods to cover, though I'll probably start on the guide before then).</p>]]></content:encoded>
    </item>
    <item>
      <title>Magic Method Monday: Reflection</title>
      <link>http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection</link>
      <pubDate>Tue, 28 Dec 2010 19:36:55 EST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Programming]]></category>
      <category><![CDATA[Magic Method Monday]]></category>
      <guid>http://rafekettler.com/?p=228</guid>
      <description>Magic Method Monday: Reflection</description>
      <content:encoded><![CDATA[<p>Sorry for the late post, but the past week has been a bit hectic, with Christmas and all. Today, we have two magic methods: <code>__instancecheck__</code> and <code>__subclasscheck__</code>: they allow us to define custom behavior for reflection.</p>
<p><code>__instancecheck__</code></p>
<p>Implements <code>isinstance(instance, class)</code>. Takes arguments <code>self</code> and <code>instance</code>.</p>
<p><code>__subclasscheck__</code></p>
<p>Implements <code>issubclass(subclass, class)</code>. Takes arguments <code>self</code> and <code>subclass</code>.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
