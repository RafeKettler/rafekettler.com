


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    
  <title>rafekettler.com</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel='stylesheet' href='/css/pygments_tango.css' type='text/css' />
<link rel='stylesheet' href='/css/site.css' type='text/css' />


  </head>
  <body>
    <div id="content">
      
  <h1><a href="/">rafekettler.com</a></h1>
<h3>My thoughts on programming and technology</h3>
<nav>
<ul>
<li><a href="/blog">Blog</a></li>
<li><a href="/about.html">About me</a></li>
<li><a href="/magicmethods.html">Magic Methods Guide</a></li>
</ul>
</nav>
<hr/>


      <div id="main_block">
        <div id="prose_block">
          

<div class="blog_post">
  <a name="magic-method-monday-custom-numeric-types"></a>
  <h2 class="blog_post_title"><a href="/blog/2010/12/20/magic-method-monday-custom-numeric-types" rel="bookmark" title="Permanent Link to Magic Method Monday: Custom Numeric Types">Magic Method Monday: Custom Numeric Types</a></h2>
  <p><small>12.20.2010 at 05:19 AM in 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/programming'>Programming</a>, <a href='/blog/category/magic-method-monday'>Magic Method Monday</a>
 | <a href="http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types#disqus_thread">View Comments</a>
</small></p>
  <div class="post_prose">
    
  <p>I've been dreading doing this MMM for a while, but it's worth it. Python magic methods can do just about anything; make sequences that behave like language constructs, make descriptors, even make comparisons using operators like <code>==</code>. Most of you have already figured out that there's a way to make classes defined by the programmer feel and work like basic numeric types. It just so happens that there's about 40 magic methods for this. Here we go:</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__add__</code></td><td>self, other</td><td>Emulates addition(<code>self + other</code>)</td></tr>
<tr><td><code>__sub__</code></td><td>self, other</td><td>Emulates subtraction (<code>self - other</code>)</td></tr>
<tr><td><code>__mul__</code></td><td>self, other</td><td>Emulates multiplication (<code>self * other</code>)</td></tr>
<tr><td><code>__floordiv__</code></td><td>self, other</td><td>Emulates integer division (<code>self // other</code>)</td></tr>
<tr><td><code>__div__</code></td><td>self, other</td><td>Emulates division (<code>self / other</code>)</td></tr>
<tr><td><code>__truediv__</code></td><td>self, other</td><td>Emulates division (<code>self / other</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__mod__</code></td><td>self, other</td><td>Emulates modulo (<code>self % other</code>)</td></tr>
<tr><td><code>__divmod__</code></td><td>self, other</td><td>Emulates long division (<code>divmod(self, other)</code>)</td></tr>
<tr><td><code>__pow__</code></td><td>self, other</td><td>Emulates exponent (<code>self**other</code>)</td></tr>
<tr><td><code>__lshift__</code></td><td>self, other</td><td>Emulates left bitwise shift (<code>self << other</code>)</td></tr>
<tr><td><code>__rshift__</code></td><td>self, other</td><td>Emulates right bitwise shift (<code>self >> other</code>)</td></tr>
<tr><td><code>__and__</code></td><td>self, other</td><td>Emulates bitwise and (<code>self & other</code>)</td></tr>
<tr><td><code>__or__</code></td><td>self, other</td><td>Emulates bitwise or (<code>self | other</code>)</td></tr>
<tr><td><code>__xor__</code></td><td>self, other</td><td>Emulates bitwise xor (<code>self ^ other</code>)</td></tr>
</table>

<p>That's it for the "normal" operators. But there's more; each one of these has a version for a reflected operand (e.g. <code>x - my_class</code>, where the primary operand is <code>x</code>, not <code>my_instance</code>). These only get called when <code>x</code> does not support the attempted operation and <code>x</code> and <code>my_instance</code> are of different types.</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__radd__</code></td><td>self, other</td><td>Emulates reflected addition(<code>other + self</code>)</td></tr>
<tr><td><code>__rsub__</code></td><td>self, other</td><td>Emulates reflected subtraction (<code>other - self</code>)</td></tr>
<tr><td><code>__rmul__</code></td><td>self, other</td><td>Emulates reflected multiplication (<code>other * self</code>)</td></tr>
<tr><td><code>__rfloordiv__</code></td><td>self, other</td><td>Emulates reflected integer division (<code>other // self</code>)</td></tr>
<tr><td><code>__rdiv__</code></td><td>self, other</td><td>Emulates reflected division (<code>other / self</code>)</td></tr>
<tr><td><code>__rtruediv__</code></td><td>self, other</td><td>Emulates reflected division (<code>other / self</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__rmod__</code></td><td>self, other</td><td>Emulates reflected modulo (<code>other % self</code>)</td></tr>
<tr><td><code>__rdivmod__</code></td><td>self, other</td><td>Emulates reflected long division (<code>divmod(other, self)</code>)</td></tr>
<tr><td><code>__rpow__</code></td><td>self, other</td><td>Emulates reflected exponent (<code>other**self</code>)</td></tr>
<tr><td><code>__rlshift__</code></td><td>self, other</td><td>Emulates reflected left bitwise shift (<code>other << self</code>)</td></tr>
<tr><td><code>__rrshift__</code></td><td>self, other</td><td>Emulates reflected right bitwise shift (<code>other >> self</code>)</td></tr>
<tr><td><code>__rand__</code></td><td>self, other</td><td>Emulates reflected bitwise and (<code>other & self</code>)</td></tr>
<tr><td><code>__ror__</code></td><td>self, other</td><td>Emulates reflected bitwise or (<code>other | self</code>)</td></tr>
<tr><td><code>__rxor__</code></td><td>self, other</td><td>Emulates reflected bitwise xor (<code>other ^ self</code>)</td></tr>
</table>

<p>And then, there's more. Each normal magic method has a version for augmented assignment (e.g. <code>my_instance += x</code>).</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__iadd__</code></td><td>self, other</td><td>Emulates augmented assignment with addition(<code>self += other</code>)</td></tr>
<tr><td><code>__isub__</code></td><td>self, other</td><td>Emulates augmented assignment with subtraction (<code>self -= other</code>)</td></tr>
<tr><td><code>__imul__</code></td><td>self, other</td><td>Emulates augmented assignment with multiplication (<code>self *= other</code>)</td></tr>
<tr><td><code>__ifloordiv__</code></td><td>self, other</td><td>Emulates augmented assignment with integer division (<code>self //= other</code>)</td></tr>
<tr><td><code>__idiv__</code></td><td>self, other</td><td>Emulates augmented assignment with division (<code>self /= other</code>)</td></tr>
<tr><td><code>__itruediv__</code></td><td>self, other</td><td>Emulates augmented assignment with division (<code>self /= other</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__imod__</code></td><td>self, other</td><td>Emulates augmented assignment with modulo (<code>self %= other</code>)</td></tr>
<tr><td><code>__ipow__</code></td><td>self, other</td><td>Emulates augmented assignment with exponent (<code>self **= other</code>)</td></tr>
<tr><td><code>__ilshift__</code></td><td>self, other</td><td>Emulates augmented assignment with left bitwise shift (<code>self <<= other</code>)</td></tr>
<tr><td><code>__irshift__</code></td><td>self, other</td><td>Emulates augmented assignment with right bitwise shift (<code>self >>= other</code>)</td></tr>
<tr><td><code>__iand__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise and (<code>self &= other</code>)</td></tr>
<tr><td><code>__ior__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise or (<code>self |= other</code>)</td></tr>
<tr><td><code>__ixor__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise xor (<code>self ^= other</code>)</td></tr>
</table>

<p>You thought it was over? It's not. We still need unary arithmetic operators.</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__pos__</code></td><td>self</td><td>Emulates unary positive(<code>+self</code>)</td></tr>
<tr><td><code>__neg__</code></td><td>self</td><td>Emulates negation<code>-self</code>)</td></tr>
<tr><td><code>__abs__</code></td><td>self</td><td>Emulates absolute value(<code>abs(self)</code>)</td></tr>
<tr><td><code>__invert__</code></td><td>self</td><td>Emulates inversion(<code>~self</code>)</td></tr>
</table>

<p>Now, we have to be able to change types:</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__float__</code></td><td>self</td><td>Converts to float(<code>float(self)</code>)</td></tr>
<tr><td><code>__int__</code></td><td>self</td><td>Converts to int(<code>int(self)</code>)</td></tr>
<tr><td><code>__long__</code></td><td>self</td><td>Converts to long(<code>long(self)</code>)</td></tr>
<tr><td><code>__complex__</code></td><td>self</td><td>Converts to complex(<code>complex(self)</code>)</td></tr>
<tr><td><code>__oct__</code></td><td>self</td><td>Converts to octal(<code>oct(self)</code>)</td></tr>
<tr><td><code>__hex__</code></td><td>self</td><td>Converts to hexadecimal(<code>hex(self)</code>)</td></tr>
</table>

<p>That's basically it. I don't want to implement a class to demonstrate any of this 1.) because it's fairly self explanatory and 2.) that would be one monster of a class.</p>

  </div>
</div>



<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_url = "http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types";
</script>
<script type="text/javascript" src="http://disqus.com/forums/rafekettler.com/embed.js"></script>
<noscript><a href="http://rafekettler.com.disqus.com/?url=ref">View the discussion thread.</a></noscript><a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

        </div><!-- End Prose Block -->
      </div><!-- End Main Block -->
      <div id="footer">
        
  <hr/>
  <p id="credits">
Copyright &copy; Rafe Kettler, 2010-11<br/>
Powered by <a href="http://www.blogofile.com">Blogofile</a>.<br/>
RSS feeds for <a href="/blog/feed">Entries</a>
 and <a
href="http://rafekettler.com.disqus.com/latest.rss">Comments</a>.
<br>
</p>
<script type="text/javascript">
//<![CDATA[
(function() {
		var links = document.getElementsByTagName('a');
		var query = '?';
		for(var i = 0; i < links.length; i++) {
			if(links[i].href.indexOf('#disqus_thread') >= 0) {
				query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
			}
		}
		document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/rafekettler.com/get_num_replies.js' + query + '"></' + 'script>');
	})();
//]]>
</script>


      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>



















