<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">rafekettler.com</title>
  <subtitle type="text">My thoughts on programming and technology</subtitle>

  <updated>2011-02-25T05:20:31Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog" />
  <id>http://www.rafekettler.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://www.rafekettler.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Functional Programming in Python on Trial]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/02/06/functional-programming-in-python-on-trial" />
    <id>http://www.rafekettler.com/blog/2011/02/06/functional-programming-in-python-on-trial</id>
    <updated>2011-02-06T04:55:56Z</updated>
    <published>2011-02-06T04:55:56Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <summary type="html"><![CDATA[Functional Programming in Python on Trial]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/02/06/functional-programming-in-python-on-trial"><![CDATA[<p>Anyone who's in the know about Python knows quite a bit about what Guido likes about Python and what he doesn't. Something that he's been very clear about for a number of years is that he doesn't like some of the functional programming constructs in Python. I'm talking about lambda expressions, <code>map()</code>, <code>filter()</code>, and <code>reduce()</code>. He said in 2005 (when he was first envisioning Python 3):</p>
<blockquote>
<p>About 12 years ago, Python aquired lambda, reduce(), filter() and map(), courtesy of (I believe) a Lisp hacker who missed them and submitted working patches. But, despite the PR value, I think these features should be cut from Python 3000. </p>
</blockquote>
<p>Ultimately, lambda, map, and filter stayed as builtins, and reduce got moved to functools. But why all the fuss? You might want to read <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">the BDFL's article on the matter</a>. For those who want a bit of a different perspective, read on.</p>
<h3>Indictment</h3>
<p>Arguably, the big problem with functional programming constructs like lambdas and map is that they are less readable than their counterparts. Most would argue that <code>[x for x in y if x &gt; 2]</code> is more readable than <code>filter(lambda x: x &gt; 2, y]</code>. I won't argue with that. But that's certainly an extreme example, isn't it? It just so happens that this example represents a case that works out very nicely in a list comprehension. In the spirit of due process, however, this and other affronts to readability serve as sufficient evidence to charge functional constructs in Python with a quite heinous crime in the Python userland: obfuscation.</p>
<h3>On the charges against lambdas</h3>
<p>First, lambda expressions. This is a feature that should not be used to produce any substantial routine. I think most of us can agree that this is evil:</p>
<div class="pygments_tango"><pre><span class="n">x</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

<p>This is bad for a number of reasons:</p>
<ol>
<li>No way to write a docstring</li>
<li>No normal function declaration -- hangs up documentation tools, makes it hard to know that function x exists by reading the source</li>
<li>One-liner (in the bad way) -- there's quite a bit going on for that one line of code</li>
</ol>
<p>Rather, it should always be written in its normal form, like so:</p>
<div class="pygments_tango"><pre><span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;I provide useful info about the function for IDEs and docs generators.</span>
<span class="sd">    I also am good for those reading source.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">functioncall</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

<p>Wasn't that better? Clearly, lambda must be guilty of the crime of obfuscation.</p>
<p>Now to sentencing: what should we do to lambda? Many would suggest to get rid of it. I say keep it. It might be obscure and unreadable in some cases, but it's a lifesaver in cases where you need to pass a very simple callback to a function. So, in the case of <code>lambda v. Python</code>, the judge finds the defendant guilty and orders him to be placed in house arrest, only to leave when used as a simple callback.</p>
<h3>On the charges against map and filter</h3>
<p>map and filter face similar charges of obfuscation. Many would argue that powerful list comprehensions obviate the need for map and filter:</p>
<div class="pygments_tango"><pre><span class="nb">map</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span> <span class="c"># more clear, relies on more &quot;standard&quot; language constructs</span>
<span class="nb">filter</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">[</span><span class="n">x</span> <span class="k">for</span>  <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="c"># likewise</span>
</pre></div>

<p>Personally, I don't find the map and filter implementations to be much less readable than their list comprehension counterparts. However, I also happen to like functional programming and I know a good bit about Python. Most people would have a hard time reading this, especially as complexity increases.</p>
<p>Along the lines of "There should be one, and only one, obvious way to do it", map and filter are guilty of crowding Python with new solutions to problems that have already been solved. In the court of Python, this is an offense punishable by death. Because of this, in the case <code>map and filter v. Python</code>, the judge finds the defendants guilty and sentences them to death. The defendants should be promptly removed from the standard library, and should only leave their places on death row for code golf competitions.</p>
<h3>reduce</h3>
<p>reduce is a fold operation, if you're familiar with other functional languages you should get this. It's a recursive concept and a common idiom in functional programming that many languages encapsulated in a higher order function (as they should have). However, Python is not a very recursive language. To demonstrate to the court why reduce is guilty, take a look at this example.</p>
<div class="pygments_tango"><pre><span class="n">x</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span> <span class="c"># what is this i don&#39;t even</span>

<p><span class="c"># equivalent in human speak</span>
<span class="n">product</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
     <span class="n">product</span> <span class="o">*=</span> <span class="n">seq</span> <span class="c"># oh, we&#39;re just finding the product of a sequence</span>
</pre></div></p>
<p>GUILTY! In this case reduce only serves to dramatically reduce(geddit) the amount of code written at the expense of any clarity. This is a simple example and is, admittedly, quite understandable and simple for anyone who has used reduce  (or fold in another language). However, as code grows in complexity, loops are almost always more clear. So, in the case of <code>reduce v. Python</code>, the judge finds the defendant not only guilty of obfuscation and lack of necessity, but also guilty of pure evil. For that, reduce meets the gallows (as it essentially has in Python 3).</p>
<h3>Syllabus (AKA tl;dr)</h3>
<p><code>lambda</code> is only acceptable in a few restricted situations. <code>map</code>, <code>filter</code>, and <code>reduce</code> need to leave the Python language because they are unnecessary and they quickly grow unwieldy and unreadable as their complexity increases.</p>
<p>I accept functional programming as a good idea in general (what would we do without closures and first-class functions, after all), but some parts of Python are relics of Lisp hackers before us and don't really fit in with the language philosophy. Because of this, I'll take Guido's side: I don't like most of the functional programming stuff mixed into Python's global namespace and syntax. I don't mind having a module for it (<code>functools</code> is useful, and when you import it it's a clear statement of intent), in fact, I happen to like that module. But in general, higher-order functions and lambdas need to be relegated to a lower place in the language.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Mixed Mode Arithmetic]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic" />
    <id>http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic</id>
    <updated>2011-01-17T17:11:15Z</updated>
    <published>2011-01-17T17:11:15Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Mixed Mode Arithmetic]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic"><![CDATA[<p>This may very well be the last magic methods blog post, and it's fitting that I'll be addressing a method that I initially overlooked.</p>
<p>Python would be very hard to use without mixed-mode arithmetic: imagine what Python would be like if a type-conversion was necessary to add an integer to a float. In order to make our classes behave the same way, we can define a <code>__coerce__</code> method.</p>
<p><code>__coerce__</code></p>
<p>Method to implement mixed mode arithmetic. Takes arguments <code>self</code> and <code>other</code>. Should return <code>None</code> if type conversion is impossible. Otherwise, it should return a pair (2-tuple) of self and other, manipulated to have the same type.</p>
<p>That's all for now; it seems that I'll have to find another weekly series to tackle. Keep watching the magic methods guide <a href="http://www.rafekettler.com/magicmethods.html">here</a>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Unicode and Nonzero]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero" />
    <id>http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero</id>
    <updated>2011-01-10T17:18:43Z</updated>
    <published>2011-01-10T17:18:43Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Unicode and Nonzero]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero"><![CDATA[<p>We're nearing the end of the magic methods blog post series (and the beginning of the magic methods guide, which will be better organized, better explained, better demonstrated, and all in one place!). Thus, I'm running out of magic methods to work with. Here we head back to a few magic methods that I ignored (or forgot): <code>__unicode__</code> and <code>__nonzero__</code>.</p>
<p><code>__unicode__</code></p>
<p>Takes argument self. It returns a unicode string representation of the instance.</p>
<p><code>__nonzero__</code></p>
<p>Takes argument self and returns a boolean value, <code>True</code> or <code>False</code>. This method gets called when the <code>bool()</code> builtin is called on an instance, e.g.</p>
<div class="pygments_tango"><pre><span class="k">if</span> <span class="n">some_instance</span><span class="p">:</span>
    <span class="c">#do something</span>
</pre></div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Follow the progress of the magic method guide]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/06/follow-the-progress-of-the-magic-method-guide" />
    <id>http://www.rafekettler.com/blog/2011/01/06/follow-the-progress-of-the-magic-method-guide</id>
    <updated>2011-01-06T23:35:28Z</updated>
    <published>2011-01-06T23:35:28Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <summary type="html"><![CDATA[Follow the progress of the magic method guide]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/06/follow-the-progress-of-the-magic-method-guide"><![CDATA[<p>I've uploaded a draft of the first few parts of the magic method guide. You can look at it <a href="http://www.rafekettler.com/magicmethods.html">here</a>.</p>
<p>Bear in mind, it's not nearly finished. I figured I'd post it in case someone wants to critique it, find some errors (I'm sure there will be some), or just follow the progress. Watch the version number as I add new content (I'm incrementing it by 1 each time I make a substantial addition, it'll be 1.0 by the time it's "content-complete").</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Context Managers]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers" />
    <id>http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers</id>
    <updated>2011-01-03T05:25:06Z</updated>
    <published>2011-01-03T05:25:06Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Context Managers]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers"><![CDATA[<p>In Python 2.5, a new keyword was introduced in Python along with a new method for code reuse, the <code>with</code> statement. The concept of context managers was hardly new in Python (it was implemented before as a part of the library, I believe), but not until <a href="http://www.python.org/dev/peps/pep-0343/">PEP 343</a> was accepted did it achieve status as a first class language construct. Usage for the <code>with</code> statement is simple:</p>
<div class="pygments_tango"><pre><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
    <span class="c"># do something</span>
</pre></div>

<p>You're probably wondering what the point of all of this is. It might look innocuous at first, but there's some magic going on behind the scenes (and, as always with Python, you can take control of that magic for yourself).</p>
<p><code>__enter__</code></p>
<p>Defines what the context manager (the <code>with</code> statement) should do at the beginning of the block. It takes the argument <code>self</code>. Whatever it returns get bound to the <em>target</em> in the <code>with</code> statement (the name after <code>as</code>), so you could in fact use <code>__enter__</code> to create a completely new object altogether (if you'd like).</p>
<p><code>__exit__</code></p>
<p>Gets loaded at the start of the block and executed after the block. It can commonly be used to handle exceptions, perform cleanup (closing a file or connection), or do something that is always done immediately after we're finished with an object. Unlike <code>__enter__</code>, <code>__exit__</code> takes several arguments, <code>self</code>, <code>exception_type</code>, <code>exception_value</code>, and <code>traceback</code>. If there's no exception, the last 3 arguments will be <code>None</code>. Otherwise, you can either choose to handle the exception or let it get handled by the user; if you want to handle it, make sure <code>__exit__</code> returns <code>True</code> after all is said and done. Otherwise, let the exception happen.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Reflection]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection" />
    <id>http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection</id>
    <updated>2010-12-28T19:36:55Z</updated>
    <published>2010-12-28T19:36:55Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Reflection]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection"><![CDATA[<p>Sorry for the late post, but the past week has been a bit hectic, with Christmas and all. Today, we have two magic methods: <code>__instancecheck__</code> and <code>__subclasscheck__</code>: they allow us to define custom behavior for reflection.</p>
<p><code>__instancecheck__</code></p>
<p>Implements <code>isinstance(instance, class)</code>. Takes arguments <code>self</code> and <code>instance</code>.</p>
<p><code>__subclasscheck__</code></p>
<p>Implements <code>issubclass(subclass, class)</code>. Takes arguments <code>self</code> and <code>subclass</code>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Custom Numeric Types]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types" />
    <id>http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types</id>
    <updated>2010-12-20T05:19:54Z</updated>
    <published>2010-12-20T05:19:54Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Custom Numeric Types]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types"><![CDATA[<p>I've been dreading doing this MMM for a while, but it's worth it. Python magic methods can do just about anything; make sequences that behave like language constructs, make descriptors, even make comparisons using operators like <code>==</code>. Most of you have already figured out that there's a way to make classes defined by the programmer feel and work like basic numeric types. It just so happens that there's about 40 magic methods for this. Here we go:</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__add__</code></td><td>self, other</td><td>Emulates addition(<code>self + other</code>)</td></tr>
<tr><td><code>__sub__</code></td><td>self, other</td><td>Emulates subtraction (<code>self - other</code>)</td></tr>
<tr><td><code>__mul__</code></td><td>self, other</td><td>Emulates multiplication (<code>self * other</code>)</td></tr>
<tr><td><code>__floordiv__</code></td><td>self, other</td><td>Emulates integer division (<code>self // other</code>)</td></tr>
<tr><td><code>__div__</code></td><td>self, other</td><td>Emulates division (<code>self / other</code>)</td></tr>
<tr><td><code>__truediv__</code></td><td>self, other</td><td>Emulates division (<code>self / other</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__mod__</code></td><td>self, other</td><td>Emulates modulo (<code>self % other</code>)</td></tr>
<tr><td><code>__divmod__</code></td><td>self, other</td><td>Emulates long division (<code>divmod(self, other)</code>)</td></tr>
<tr><td><code>__pow__</code></td><td>self, other</td><td>Emulates exponent (<code>self**other</code>)</td></tr>
<tr><td><code>__lshift__</code></td><td>self, other</td><td>Emulates left bitwise shift (<code>self << other</code>)</td></tr>
<tr><td><code>__rshift__</code></td><td>self, other</td><td>Emulates right bitwise shift (<code>self >> other</code>)</td></tr>
<tr><td><code>__and__</code></td><td>self, other</td><td>Emulates bitwise and (<code>self & other</code>)</td></tr>
<tr><td><code>__or__</code></td><td>self, other</td><td>Emulates bitwise or (<code>self | other</code>)</td></tr>
<tr><td><code>__xor__</code></td><td>self, other</td><td>Emulates bitwise xor (<code>self ^ other</code>)</td></tr>
</table>

<p>That's it for the "normal" operators. But there's more; each one of these has a version for a reflected operand (e.g. <code>x - my_class</code>, where the primary operand is <code>x</code>, not <code>my_instance</code>). These only get called when <code>x</code> does not support the attempted operation and <code>x</code> and <code>my_instance</code> are of different types.</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__radd__</code></td><td>self, other</td><td>Emulates reflected addition(<code>other + self</code>)</td></tr>
<tr><td><code>__rsub__</code></td><td>self, other</td><td>Emulates reflected subtraction (<code>other - self</code>)</td></tr>
<tr><td><code>__rmul__</code></td><td>self, other</td><td>Emulates reflected multiplication (<code>other * self</code>)</td></tr>
<tr><td><code>__rfloordiv__</code></td><td>self, other</td><td>Emulates reflected integer division (<code>other // self</code>)</td></tr>
<tr><td><code>__rdiv__</code></td><td>self, other</td><td>Emulates reflected division (<code>other / self</code>)</td></tr>
<tr><td><code>__rtruediv__</code></td><td>self, other</td><td>Emulates reflected division (<code>other / self</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__rmod__</code></td><td>self, other</td><td>Emulates reflected modulo (<code>other % self</code>)</td></tr>
<tr><td><code>__rdivmod__</code></td><td>self, other</td><td>Emulates reflected long division (<code>divmod(other, self)</code>)</td></tr>
<tr><td><code>__rpow__</code></td><td>self, other</td><td>Emulates reflected exponent (<code>other**self</code>)</td></tr>
<tr><td><code>__rlshift__</code></td><td>self, other</td><td>Emulates reflected left bitwise shift (<code>other << self</code>)</td></tr>
<tr><td><code>__rrshift__</code></td><td>self, other</td><td>Emulates reflected right bitwise shift (<code>other >> self</code>)</td></tr>
<tr><td><code>__rand__</code></td><td>self, other</td><td>Emulates reflected bitwise and (<code>other & self</code>)</td></tr>
<tr><td><code>__ror__</code></td><td>self, other</td><td>Emulates reflected bitwise or (<code>other | self</code>)</td></tr>
<tr><td><code>__rxor__</code></td><td>self, other</td><td>Emulates reflected bitwise xor (<code>other ^ self</code>)</td></tr>
</table>

<p>And then, there's more. Each normal magic method has a version for augmented assignment (e.g. <code>my_instance += x</code>).</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__iadd__</code></td><td>self, other</td><td>Emulates augmented assignment with addition(<code>self += other</code>)</td></tr>
<tr><td><code>__isub__</code></td><td>self, other</td><td>Emulates augmented assignment with subtraction (<code>self -= other</code>)</td></tr>
<tr><td><code>__imul__</code></td><td>self, other</td><td>Emulates augmented assignment with multiplication (<code>self *= other</code>)</td></tr>
<tr><td><code>__ifloordiv__</code></td><td>self, other</td><td>Emulates augmented assignment with integer division (<code>self //= other</code>)</td></tr>
<tr><td><code>__idiv__</code></td><td>self, other</td><td>Emulates augmented assignment with division (<code>self /= other</code>)</td></tr>
<tr><td><code>__itruediv__</code></td><td>self, other</td><td>Emulates augmented assignment with division (<code>self /= other</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__imod__</code></td><td>self, other</td><td>Emulates augmented assignment with modulo (<code>self %= other</code>)</td></tr>
<tr><td><code>__ipow__</code></td><td>self, other</td><td>Emulates augmented assignment with exponent (<code>self **= other</code>)</td></tr>
<tr><td><code>__ilshift__</code></td><td>self, other</td><td>Emulates augmented assignment with left bitwise shift (<code>self <<= other</code>)</td></tr>
<tr><td><code>__irshift__</code></td><td>self, other</td><td>Emulates augmented assignment with right bitwise shift (<code>self >>= other</code>)</td></tr>
<tr><td><code>__iand__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise and (<code>self &= other</code>)</td></tr>
<tr><td><code>__ior__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise or (<code>self |= other</code>)</td></tr>
<tr><td><code>__ixor__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise xor (<code>self ^= other</code>)</td></tr>
</table>

<p>You thought it was over? It's not. We still need unary arithmetic operators.</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__pos__</code></td><td>self</td><td>Emulates unary positive(<code>+self</code>)</td></tr>
<tr><td><code>__neg__</code></td><td>self</td><td>Emulates negation<code>-self</code>)</td></tr>
<tr><td><code>__abs__</code></td><td>self</td><td>Emulates absolute value(<code>abs(self)</code>)</td></tr>
<tr><td><code>__invert__</code></td><td>self</td><td>Emulates inversion(<code>~self</code>)</td></tr>
</table>

<p>Now, we have to be able to change types:</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__float__</code></td><td>self</td><td>Converts to float(<code>float(self)</code>)</td></tr>
<tr><td><code>__int__</code></td><td>self</td><td>Converts to int(<code>int(self)</code>)</td></tr>
<tr><td><code>__long__</code></td><td>self</td><td>Converts to long(<code>long(self)</code>)</td></tr>
<tr><td><code>__complex__</code></td><td>self</td><td>Converts to complex(<code>complex(self)</code>)</td></tr>
<tr><td><code>__oct__</code></td><td>self</td><td>Converts to octal(<code>oct(self)</code>)</td></tr>
<tr><td><code>__hex__</code></td><td>self</td><td>Converts to hexadecimal(<code>hex(self)</code>)</td></tr>
</table>

<p>That's basically it. I don't want to implement a class to demonstrate any of this 1.) because it's fairly self explanatory and 2.) that would be one monster of a class.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Methods: Sequences Continued]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/17/magic-methods-sequences-continued" />
    <id>http://www.rafekettler.com/blog/2010/12/17/magic-methods-sequences-continued</id>
    <updated>2010-12-17T22:37:33Z</updated>
    <published>2010-12-17T22:37:33Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Methods: Sequences Continued]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/17/magic-methods-sequences-continued"><![CDATA[<p>It came to my attention that I left out a few magic methods when I covered sequences a few months ago. I know it's not Monday, but I don't feel like waiting to tackle this, and I have a free minute now.</p>
<p><code>__reversed__</code></p>
<p><code>__reversed</code> defines behavior for when you call <code>reversed()</code> on your sequence. Takes self.</p>
<p><code>__contains__</code></p>
<p><code>__contains</code> defines behavior for when we use <code>in</code> with a custom sequence, e.g. <code>x in y</code> or <code>x not in y</code>. It takes arguments self and item to test for membership. Note that this doesn't need to be defined for <code>in</code> to work with a custom sequence; the default behavior for <code>x in y</code> is to iterate over y and return True if any of the values in y are x.</p>
<p>That's all for today, happy holidays everyone.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Descriptors]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/13/magic-method-monday-descriptors" />
    <id>http://www.rafekettler.com/blog/2010/12/13/magic-method-monday-descriptors</id>
    <updated>2010-12-13T04:19:15Z</updated>
    <published>2010-12-13T04:19:15Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Descriptors]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/13/magic-method-monday-descriptors"><![CDATA[<p>Descriptors are classes which, when accessed through either getting, setting, or deleting, can also alter other objects. Descriptors aren't meant to stand alone; rather, they're meant to be held by an owner class. Descriptors can be useful when building object-oriented databases or classes that have attributes whose values are dependent on each other.</p>
<p>To be a descriptor, a class must have at least one of <code>__get__</code>, <code>__set__</code>, and <code>__delete__</code> implemented. Let's take a look at those magic methods:</p>
<p><code>__get__</code></p>
<p><code>__get__</code> defines behavior for when the descriptor's value is retrieved. <code>__get__</code> takes three arguments: <code>self</code>, the instance of the owner class (<code>instance</code>), and the owner class itself (<code>owner</code>).</p>
<p><code>__set__</code></p>
<p><code>__set__</code></p>
<p><code>__set__</code> gets called when the value of the descriptor is changed. It takes three arguments also: <code>self</code>, the instance of the owner class, and the value to set the descriptor to.</p>
<p><code>__delete__</code></p>
<p><code>__delete__</code> gets called when the descriptor (or the instance of the owner) is deleted (either through garbage collection or a <code>del</code> statement), and it takes <code>self</code> and the instance of the owner class.</p>
<p><strong>Example</strong></p>
<p>If one were defining a class to represent distance (or any other measurement), it might be useful to have multiple units of measurement represented. An example could look like this:</p>
<div class="pygments_tango"><pre><span class="k">class</span> <span class="nc">Meter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<p><span class="k">class</span> <span class="nc">Foot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf"><strong>get</strong></span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">meter</span> <span class="o">/</span> <span class="o">.</span><span class="mi">3048</span>
    <span class="k">def</span> <span class="nf"><strong>set</strong></span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">meter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3.2808</span></p>
<p><span class="k">class</span> <span class="nc">Distance</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">meter</span> <span class="o">=</span> <span class="n">Meter</span><span class="p">()</span>
    <span class="n">foot</span> <span class="o">=</span> <span class="n">Foot</span><span class="p">()</span>
</pre></div></p>
<p>In this case, <code>Meter</code> and <code>Foot</code> are descriptors, and <code>Distance</code> is the owner class. Descriptors are useful because they can tie values and other aspects of their state to other descriptors, making them an excellent way to simply and beautify code. Without descriptors in this example, the implementation of the conversions would have to be contained in <code>Distance</code>, which would not only bloat the class definition for <code>Distance</code>, but make <code>Foot</code> and <code>Meter</code> specific to <code>Distance</code>. By defining <code>__get__</code>, <code>__set__</code>, and <code>__delete__</code>, however, we can reuse <code>Foot</code> and <code>Meter</code> in any class that has some attribute for distance. All in all, it's a great way to write reusable, effortless code that can add functionality and beauty to classes that hold them.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Other languages have magic methods?!?]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/04/other-languages-have-magic-methods" />
    <id>http://www.rafekettler.com/blog/2010/12/04/other-languages-have-magic-methods</id>
    <updated>2010-12-04T18:26:02Z</updated>
    <published>2010-12-04T18:26:02Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="PHP" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <summary type="html"><![CDATA[Other languages have magic methods?!?]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/04/other-languages-have-magic-methods"><![CDATA[<p>I've been teaching myself PHP and I've discovered that PHP uses magic methods, like Python. I have mixed feelings about this: I like that PHP uses the awesomeness that is magic methods, and I like that they took hints from Python<sup>[<a name="id394062" href="#ftn.id394062">1</a>]</sup> (I did some research, and PHP's magic methods only came in PHP 3, circa 1998, whereas Python has had magic methods since before 1.0). I don't, however, like that their magic methods start with two underscores but have no trailing underscores (this will conflict with some of the naming practices that I'm used to, but I'm sure it won't be a problem in a language with true visibility control), and that they have different names than their Python counterparts.</p>
<p>So, for my convenience and the convenience of other Pythonistas that find they must use PHP (not the worst fate, but not as clean as I'm used to), I've written up some PHP magic methods and their Python equivalents for easy reference. For actual reference, you can actually go to the <a href="http://us3.php.net/manual/en/language.oop5.php">PHP manual's pages on classes</a> and look at how they describe them.</p>
<ul>
<li><code>__construct</code> translates to <code>__init__</code></li>
<li><code>__destruct</code> translates (roughly) to <code>__del__</code>, since it gets called when an object gets deleted, though I haven't learned yet how to explicitly delete a PHP object</li>
<li><code>__call</code> doesn't have a direct equivalent. It defines some standard behavior when a method is called. It can be emulated with <code>__getattr__</code> (see <a href="http://stackoverflow.com/questions/1626478/python-getattribute-or-getattr-to-emulate-php-call">this</a> for how), but I don't see why it would be needed. Similar behavior can be achieved with decorators (in a more explicit and deliberate manner, too).</li>
<li><code>__callStatic</code> is the same story, it's like <code>__call</code> but it gets invoked when a method is called in a static context.</li>
<li><code>__get</code> and <code>__set</code> are similar to Python's <code>property()</code> function, in that they allow you to define behavior for attribute access.</li>
<li><code>__toStr</code> is equivalent to <code>__str__</code></li>
<li><code>__invoke</code> is equivalent to <code>__call__</code></li>
</ul>
<p>Sadly, PHP doesn't readily support a lot of the stuff that makes classes so cool and so powerful in Python. In Python, operator overloading is as simple as defining <code>__add__</code> or <code>__eq__</code>, but PHP doesn't let you do this. It's also not really possible to make classes behave as types, like we know and cherish in Python.</p>
<p>As for a brief review on my journey into PHP so far: for someone coming from a Java/Python background, it's very easy to learn. Very few things have confused/surprised me so far (except for the inconsistent/nonsense naming of functions and methods). The main advantage of PHP, IMO, is convenience: it's always there, without having to use CGI or a framework it's web-ready, which is good for a lot of things, particularly small tasks.</p>
<div class="footnote"><sup>[<a name="ftn.id394062" href="#id394062">1</a>]</sup>
This is a conceited statement coming from a Python ultranationalist. I know Python had magic methods way before PHP, but I can't be certain that's where PHP got it from (Python may have gotten magic methods from somewhere else), or that Rasmus Lerdorf didn't just come up with the idea himself (though that's doubtful)</div>]]></content>
  </entry>
</feed>
