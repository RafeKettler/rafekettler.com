<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">rafekettler.com</title>
  <subtitle type="text">My thoughts on programming and technology</subtitle>

  <updated>2011-02-25T05:20:31Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog" />
  <id>http://www.rafekettler.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://www.rafekettler.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Mixed Mode Arithmetic]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic" />
    <id>http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic</id>
    <updated>2011-01-17T17:11:15Z</updated>
    <published>2011-01-17T17:11:15Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Mixed Mode Arithmetic]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/17/magic-method-monday-mixed-mode-arithmetic"><![CDATA[<p>This may very well be the last magic methods blog post, and it's fitting that I'll be addressing a method that I initially overlooked.</p>
<p>Python would be very hard to use without mixed-mode arithmetic: imagine what Python would be like if a type-conversion was necessary to add an integer to a float. In order to make our classes behave the same way, we can define a <code>__coerce__</code> method.</p>
<p><code>__coerce__</code></p>
<p>Method to implement mixed mode arithmetic. Takes arguments <code>self</code> and <code>other</code>. Should return <code>None</code> if type conversion is impossible. Otherwise, it should return a pair (2-tuple) of self and other, manipulated to have the same type.</p>
<p>That's all for now; it seems that I'll have to find another weekly series to tackle. Keep watching the magic methods guide <a href="http://www.rafekettler.com/magicmethods.html">here</a>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Unicode and Nonzero]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero" />
    <id>http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero</id>
    <updated>2011-01-10T17:18:43Z</updated>
    <published>2011-01-10T17:18:43Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Unicode and Nonzero]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/10/magic-method-monday-unicode-and-nonzero"><![CDATA[<p>We're nearing the end of the magic methods blog post series (and the beginning of the magic methods guide, which will be better organized, better explained, better demonstrated, and all in one place!). Thus, I'm running out of magic methods to work with. Here we head back to a few magic methods that I ignored (or forgot): <code>__unicode__</code> and <code>__nonzero__</code>.</p>
<p><code>__unicode__</code></p>
<p>Takes argument self. It returns a unicode string representation of the instance.</p>
<p><code>__nonzero__</code></p>
<p>Takes argument self and returns a boolean value, <code>True</code> or <code>False</code>. This method gets called when the <code>bool()</code> builtin is called on an instance, e.g.</p>
<div class="pygments_tango"><pre><span class="k">if</span> <span class="n">some_instance</span><span class="p">:</span>
    <span class="c">#do something</span>
</pre></div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Context Managers]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers" />
    <id>http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers</id>
    <updated>2011-01-03T05:25:06Z</updated>
    <published>2011-01-03T05:25:06Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Context Managers]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/03/magic-method-monday-context-managers"><![CDATA[<p>In Python 2.5, a new keyword was introduced in Python along with a new method for code reuse, the <code>with</code> statement. The concept of context managers was hardly new in Python (it was implemented before as a part of the library, I believe), but not until <a href="http://www.python.org/dev/peps/pep-0343/">PEP 343</a> was accepted did it achieve status as a first class language construct. Usage for the <code>with</code> statement is simple:</p>
<div class="pygments_tango"><pre><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
    <span class="c"># do something</span>
</pre></div>

<p>You're probably wondering what the point of all of this is. It might look innocuous at first, but there's some magic going on behind the scenes (and, as always with Python, you can take control of that magic for yourself).</p>
<p><code>__enter__</code></p>
<p>Defines what the context manager (the <code>with</code> statement) should do at the beginning of the block. It takes the argument <code>self</code>. Whatever it returns get bound to the <em>target</em> in the <code>with</code> statement (the name after <code>as</code>), so you could in fact use <code>__enter__</code> to create a completely new object altogether (if you'd like).</p>
<p><code>__exit__</code></p>
<p>Gets loaded at the start of the block and executed after the block. It can commonly be used to handle exceptions, perform cleanup (closing a file or connection), or do something that is always done immediately after we're finished with an object. Unlike <code>__enter__</code>, <code>__exit__</code> takes several arguments, <code>self</code>, <code>exception_type</code>, <code>exception_value</code>, and <code>traceback</code>. If there's no exception, the last 3 arguments will be <code>None</code>. Otherwise, you can either choose to handle the exception or let it get handled by the user; if you want to handle it, make sure <code>__exit__</code> returns <code>True</code> after all is said and done. Otherwise, let the exception happen.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Methods Guide, Coming Up]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2011/01/01/magic-methods-guide-coming-up" />
    <id>http://www.rafekettler.com/blog/2011/01/01/magic-methods-guide-coming-up</id>
    <updated>2011-01-01T18:03:03Z</updated>
    <published>2011-01-01T18:03:03Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Methods Guide, Coming Up]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2011/01/01/magic-methods-guide-coming-up"><![CDATA[<p>Soon enough, I'll be creating an organized guide to Python's magic methods that will be more or less an aggregation of my blog posts on the matter, perhaps with a few more examples.</p>
<p>I'll at least make it available in HTML and PDF format, but I'm not sure where (I'm leaning towards creating a new subdomain to host it, but who knows). It will definitely be available from my blog, I'm just not sure if I want to jump through WordPress hoops to make the static content work right. I may just end up using plain HTML with a little embellishment (it'll also give me a great chance to use GeSHi manually, if I so choose).</p>
<p>Keep on the lookout for it, it should be coming in the next month or so (I have a few more weeks of Magic Method Monday blog posts before I run out of methods to cover, though I'll probably start on the guide before then).</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Reflection]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection" />
    <id>http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection</id>
    <updated>2010-12-28T19:36:55Z</updated>
    <published>2010-12-28T19:36:55Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Reflection]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/28/magic-method-monday-reflection"><![CDATA[<p>Sorry for the late post, but the past week has been a bit hectic, with Christmas and all. Today, we have two magic methods: <code>__instancecheck__</code> and <code>__subclasscheck__</code>: they allow us to define custom behavior for reflection.</p>
<p><code>__instancecheck__</code></p>
<p>Implements <code>isinstance(instance, class)</code>. Takes arguments <code>self</code> and <code>instance</code>.</p>
<p><code>__subclasscheck__</code></p>
<p>Implements <code>issubclass(subclass, class)</code>. Takes arguments <code>self</code> and <code>subclass</code>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Custom Numeric Types]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types" />
    <id>http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types</id>
    <updated>2010-12-20T05:19:54Z</updated>
    <published>2010-12-20T05:19:54Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Custom Numeric Types]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/20/magic-method-monday-custom-numeric-types"><![CDATA[<p>I've been dreading doing this MMM for a while, but it's worth it. Python magic methods can do just about anything; make sequences that behave like language constructs, make descriptors, even make comparisons using operators like <code>==</code>. Most of you have already figured out that there's a way to make classes defined by the programmer feel and work like basic numeric types. It just so happens that there's about 40 magic methods for this. Here we go:</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__add__</code></td><td>self, other</td><td>Emulates addition(<code>self + other</code>)</td></tr>
<tr><td><code>__sub__</code></td><td>self, other</td><td>Emulates subtraction (<code>self - other</code>)</td></tr>
<tr><td><code>__mul__</code></td><td>self, other</td><td>Emulates multiplication (<code>self * other</code>)</td></tr>
<tr><td><code>__floordiv__</code></td><td>self, other</td><td>Emulates integer division (<code>self // other</code>)</td></tr>
<tr><td><code>__div__</code></td><td>self, other</td><td>Emulates division (<code>self / other</code>)</td></tr>
<tr><td><code>__truediv__</code></td><td>self, other</td><td>Emulates division (<code>self / other</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__mod__</code></td><td>self, other</td><td>Emulates modulo (<code>self % other</code>)</td></tr>
<tr><td><code>__divmod__</code></td><td>self, other</td><td>Emulates long division (<code>divmod(self, other)</code>)</td></tr>
<tr><td><code>__pow__</code></td><td>self, other</td><td>Emulates exponent (<code>self**other</code>)</td></tr>
<tr><td><code>__lshift__</code></td><td>self, other</td><td>Emulates left bitwise shift (<code>self << other</code>)</td></tr>
<tr><td><code>__rshift__</code></td><td>self, other</td><td>Emulates right bitwise shift (<code>self >> other</code>)</td></tr>
<tr><td><code>__and__</code></td><td>self, other</td><td>Emulates bitwise and (<code>self & other</code>)</td></tr>
<tr><td><code>__or__</code></td><td>self, other</td><td>Emulates bitwise or (<code>self | other</code>)</td></tr>
<tr><td><code>__xor__</code></td><td>self, other</td><td>Emulates bitwise xor (<code>self ^ other</code>)</td></tr>
</table>

<p>That's it for the "normal" operators. But there's more; each one of these has a version for a reflected operand (e.g. <code>x - my_class</code>, where the primary operand is <code>x</code>, not <code>my_instance</code>). These only get called when <code>x</code> does not support the attempted operation and <code>x</code> and <code>my_instance</code> are of different types.</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__radd__</code></td><td>self, other</td><td>Emulates reflected addition(<code>other + self</code>)</td></tr>
<tr><td><code>__rsub__</code></td><td>self, other</td><td>Emulates reflected subtraction (<code>other - self</code>)</td></tr>
<tr><td><code>__rmul__</code></td><td>self, other</td><td>Emulates reflected multiplication (<code>other * self</code>)</td></tr>
<tr><td><code>__rfloordiv__</code></td><td>self, other</td><td>Emulates reflected integer division (<code>other // self</code>)</td></tr>
<tr><td><code>__rdiv__</code></td><td>self, other</td><td>Emulates reflected division (<code>other / self</code>)</td></tr>
<tr><td><code>__rtruediv__</code></td><td>self, other</td><td>Emulates reflected division (<code>other / self</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__rmod__</code></td><td>self, other</td><td>Emulates reflected modulo (<code>other % self</code>)</td></tr>
<tr><td><code>__rdivmod__</code></td><td>self, other</td><td>Emulates reflected long division (<code>divmod(other, self)</code>)</td></tr>
<tr><td><code>__rpow__</code></td><td>self, other</td><td>Emulates reflected exponent (<code>other**self</code>)</td></tr>
<tr><td><code>__rlshift__</code></td><td>self, other</td><td>Emulates reflected left bitwise shift (<code>other << self</code>)</td></tr>
<tr><td><code>__rrshift__</code></td><td>self, other</td><td>Emulates reflected right bitwise shift (<code>other >> self</code>)</td></tr>
<tr><td><code>__rand__</code></td><td>self, other</td><td>Emulates reflected bitwise and (<code>other & self</code>)</td></tr>
<tr><td><code>__ror__</code></td><td>self, other</td><td>Emulates reflected bitwise or (<code>other | self</code>)</td></tr>
<tr><td><code>__rxor__</code></td><td>self, other</td><td>Emulates reflected bitwise xor (<code>other ^ self</code>)</td></tr>
</table>

<p>And then, there's more. Each normal magic method has a version for augmented assignment (e.g. <code>my_instance += x</code>).</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__iadd__</code></td><td>self, other</td><td>Emulates augmented assignment with addition(<code>self += other</code>)</td></tr>
<tr><td><code>__isub__</code></td><td>self, other</td><td>Emulates augmented assignment with subtraction (<code>self -= other</code>)</td></tr>
<tr><td><code>__imul__</code></td><td>self, other</td><td>Emulates augmented assignment with multiplication (<code>self *= other</code>)</td></tr>
<tr><td><code>__ifloordiv__</code></td><td>self, other</td><td>Emulates augmented assignment with integer division (<code>self //= other</code>)</td></tr>
<tr><td><code>__idiv__</code></td><td>self, other</td><td>Emulates augmented assignment with division (<code>self /= other</code>)</td></tr>
<tr><td><code>__itruediv__</code></td><td>self, other</td><td>Emulates augmented assignment with division (<code>self /= other</code>) when <code>from __future__ import division</code> is in effect</td></tr>
<tr><td><code>__imod__</code></td><td>self, other</td><td>Emulates augmented assignment with modulo (<code>self %= other</code>)</td></tr>
<tr><td><code>__ipow__</code></td><td>self, other</td><td>Emulates augmented assignment with exponent (<code>self **= other</code>)</td></tr>
<tr><td><code>__ilshift__</code></td><td>self, other</td><td>Emulates augmented assignment with left bitwise shift (<code>self <<= other</code>)</td></tr>
<tr><td><code>__irshift__</code></td><td>self, other</td><td>Emulates augmented assignment with right bitwise shift (<code>self >>= other</code>)</td></tr>
<tr><td><code>__iand__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise and (<code>self &= other</code>)</td></tr>
<tr><td><code>__ior__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise or (<code>self |= other</code>)</td></tr>
<tr><td><code>__ixor__</code></td><td>self, other</td><td>Emulates augmented assignment with bitwise xor (<code>self ^= other</code>)</td></tr>
</table>

<p>You thought it was over? It's not. We still need unary arithmetic operators.</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__pos__</code></td><td>self</td><td>Emulates unary positive(<code>+self</code>)</td></tr>
<tr><td><code>__neg__</code></td><td>self</td><td>Emulates negation<code>-self</code>)</td></tr>
<tr><td><code>__abs__</code></td><td>self</td><td>Emulates absolute value(<code>abs(self)</code>)</td></tr>
<tr><td><code>__invert__</code></td><td>self</td><td>Emulates inversion(<code>~self</code>)</td></tr>
</table>

<p>Now, we have to be able to change types:</p>
<table>
<tr><td><strong>Magic Method</strong></td><td><strong>Arguments</strong></td><td><strong>Description</strong></td></tr>
<tr><td><code>__float__</code></td><td>self</td><td>Converts to float(<code>float(self)</code>)</td></tr>
<tr><td><code>__int__</code></td><td>self</td><td>Converts to int(<code>int(self)</code>)</td></tr>
<tr><td><code>__long__</code></td><td>self</td><td>Converts to long(<code>long(self)</code>)</td></tr>
<tr><td><code>__complex__</code></td><td>self</td><td>Converts to complex(<code>complex(self)</code>)</td></tr>
<tr><td><code>__oct__</code></td><td>self</td><td>Converts to octal(<code>oct(self)</code>)</td></tr>
<tr><td><code>__hex__</code></td><td>self</td><td>Converts to hexadecimal(<code>hex(self)</code>)</td></tr>
</table>

<p>That's basically it. I don't want to implement a class to demonstrate any of this 1.) because it's fairly self explanatory and 2.) that would be one monster of a class.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Methods: Sequences Continued]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/17/magic-methods-sequences-continued" />
    <id>http://www.rafekettler.com/blog/2010/12/17/magic-methods-sequences-continued</id>
    <updated>2010-12-17T22:37:33Z</updated>
    <published>2010-12-17T22:37:33Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Methods: Sequences Continued]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/17/magic-methods-sequences-continued"><![CDATA[<p>It came to my attention that I left out a few magic methods when I covered sequences a few months ago. I know it's not Monday, but I don't feel like waiting to tackle this, and I have a free minute now.</p>
<p><code>__reversed__</code></p>
<p><code>__reversed</code> defines behavior for when you call <code>reversed()</code> on your sequence. Takes self.</p>
<p><code>__contains__</code></p>
<p><code>__contains</code> defines behavior for when we use <code>in</code> with a custom sequence, e.g. <code>x in y</code> or <code>x not in y</code>. It takes arguments self and item to test for membership. Note that this doesn't need to be defined for <code>in</code> to work with a custom sequence; the default behavior for <code>x in y</code> is to iterate over y and return True if any of the values in y are x.</p>
<p>That's all for today, happy holidays everyone.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: Descriptors]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/12/13/magic-method-monday-descriptors" />
    <id>http://www.rafekettler.com/blog/2010/12/13/magic-method-monday-descriptors</id>
    <updated>2010-12-13T04:19:15Z</updated>
    <published>2010-12-13T04:19:15Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Programming" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: Descriptors]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/12/13/magic-method-monday-descriptors"><![CDATA[<p>Descriptors are classes which, when accessed through either getting, setting, or deleting, can also alter other objects. Descriptors aren't meant to stand alone; rather, they're meant to be held by an owner class. Descriptors can be useful when building object-oriented databases or classes that have attributes whose values are dependent on each other.</p>
<p>To be a descriptor, a class must have at least one of <code>__get__</code>, <code>__set__</code>, and <code>__delete__</code> implemented. Let's take a look at those magic methods:</p>
<p><code>__get__</code></p>
<p><code>__get__</code> defines behavior for when the descriptor's value is retrieved. <code>__get__</code> takes three arguments: <code>self</code>, the instance of the owner class (<code>instance</code>), and the owner class itself (<code>owner</code>).</p>
<p><code>__set__</code></p>
<p><code>__set__</code></p>
<p><code>__set__</code> gets called when the value of the descriptor is changed. It takes three arguments also: <code>self</code>, the instance of the owner class, and the value to set the descriptor to.</p>
<p><code>__delete__</code></p>
<p><code>__delete__</code> gets called when the descriptor (or the instance of the owner) is deleted (either through garbage collection or a <code>del</code> statement), and it takes <code>self</code> and the instance of the owner class.</p>
<p><strong>Example</strong></p>
<p>If one were defining a class to represent distance (or any other measurement), it might be useful to have multiple units of measurement represented. An example could look like this:</p>
<div class="pygments_tango"><pre><span class="k">class</span> <span class="nc">Meter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<p><span class="k">class</span> <span class="nc">Foot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf"><strong>get</strong></span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">meter</span> <span class="o">/</span> <span class="o">.</span><span class="mi">3048</span>
    <span class="k">def</span> <span class="nf"><strong>set</strong></span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">meter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3.2808</span></p>
<p><span class="k">class</span> <span class="nc">Distance</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">meter</span> <span class="o">=</span> <span class="n">Meter</span><span class="p">()</span>
    <span class="n">foot</span> <span class="o">=</span> <span class="n">Foot</span><span class="p">()</span>
</pre></div></p>
<p>In this case, <code>Meter</code> and <code>Foot</code> are descriptors, and <code>Distance</code> is the owner class. Descriptors are useful because they can tie values and other aspects of their state to other descriptors, making them an excellent way to simply and beautify code. Without descriptors in this example, the implementation of the conversions would have to be contained in <code>Distance</code>, which would not only bloat the class definition for <code>Distance</code>, but make <code>Foot</code> and <code>Meter</code> specific to <code>Distance</code>. By defining <code>__get__</code>, <code>__set__</code>, and <code>__delete__</code>, however, we can reuse <code>Foot</code> and <code>Meter</code> in any class that has some attribute for distance. All in all, it's a great way to write reusable, effortless code that can add functionality and beauty to classes that hold them.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: __call__()]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/11/29/magic-method-monday-__call__" />
    <id>http://www.rafekettler.com/blog/2010/11/29/magic-method-monday-__call__</id>
    <updated>2010-11-29T06:14:42Z</updated>
    <published>2010-11-29T06:14:42Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: __call__()]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/11/29/magic-method-monday-__call__"><![CDATA[<p>Busy week, so only one magic method this Monday. This one's a bit strange, but a useful feature of Python nonetheless. Today, we look at <code>__call__()</code>, which defines behavior when an instance of a class is called.</p>
<p><code>__call__()</code></p>
<p>Defines behavior when an instance of a class is called, e.g.</p>
<div class="pygments_tango"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="n">x</span><span class="p">()</span>
</pre></div>

<p><code>__call__()</code> takes the parameters <code>self</code> and anything else you'd like it to take.</p>
<p><strong>Example</strong></p>
<p>Here's an example that adds functionality to Tkinter callbacks, which are useful but can't take arguments (which is something you'd often like them to take):</p>
<div class="pygments_tango"><pre><span class="k">class</span> <span class="nc">Callback</span><span class="p">:</span>

<pre><code>&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kw&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__call__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
</code></pre>
<p></pre></div></p>
<p>What this accomplished is it allows us to create instances for particular callbacks, and pass them arguments despite Tkinter's limitations. Normally, we'd do this:</p>
<div class="pygments_tango"><pre><span class="n">button</span> <span class="o">=</span> <span class="n">Tkinter</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Button&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
</pre></div>

<p>But now we can do this:</p>
<div class="pygments_tango"><pre><span class="n">button</span> <span class="o">=</span> <span class="n">Tkinter</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Button&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">=</span><span class="n">Callback</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span>
</pre></div>

<p>It may not seem like much, but if you work with Tkinter a lot, you know how much frustration this can avoid.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://www.rafekettler.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Magic Method Monday: __str__, __repr__, and __hash__]]></title>
    <link rel="alternate" type="text/html" href="http://www.rafekettler.com/blog/2010/11/22/magic-method-monday-__str__-__repr__-and-__hash__" />
    <id>http://www.rafekettler.com/blog/2010/11/22/magic-method-monday-__str__-__repr__-and-__hash__</id>
    <updated>2010-11-22T17:30:48Z</updated>
    <published>2010-11-22T17:30:48Z</published>
    <category scheme="http://www.rafekettler.com/blog" term="Python" />
    <category scheme="http://www.rafekettler.com/blog" term="Magic Method Monday" />
    <summary type="html"><![CDATA[Magic Method Monday: __str__, __repr__, and __hash__]]></summary>
    <content type="html" xml:base="http://www.rafekettler.com/blog/2010/11/22/magic-method-monday-__str__-__repr__-and-__hash__"><![CDATA[<p>One of the best parts about Python's magic methods is that they allow you to control exactly how built-in functions operate on custom objects. Today, we'll look at how to define custom behavior for the <code>str()</code>, <code>repr()</code>, and <code>hash()</code>. These functions are important parts of basic Python.</p>
<p><strong>str(), repr(), and hash()</strong></p>
<p>Very quickly, we'll look at what these functions do. str() returns a nicely printable version of an object, repr() returns a more detailed representation of an object, more suitable for debugging (that is always a valid Python expression), and hash() is able to return a hash value for certain data types (e.g. characters, strings, integers, floats). An example session with the interpreter:</p>
<div class="pygments_tango"><pre>&gt;&gt;&gt; str(&#39;a&#39;)
&#39;a&#39;
&gt;&gt;&gt; repr(&#39;a&#39;)
&quot;&#39;a&#39;&quot;
&gt;&gt;&gt; hash(&#39;a&#39;)
-468864544
</pre></div>

<p><code>__str__</code></p>
<p>Defines custom behavior when str() is called on an object. It takes the argument self and returns a string.</p>
<p><code>__repr__</code></p>
<p>Defines custom behavior when repr() is called on an object. It takes the argument self and returns a string. The returned value, if possible, should be a valid Python expression that could be used to reproduce the object.</p>
<p><code>__hash__</code></p>
<p>Defines how Python behaves when hash() is called on an object. This can be particularly useful for creating dictionaries and other mappings. It takes arguments self and returns an integer hash value. By default, the hash() function isn't particularly good, because it allows for collisions (<code>hash(1)</code> and <code>hash(1.0)</code> will return the same values).</p>
<p><strong>In action: a useful example, finally</strong></p>
<p>Usually when I give examples for Magic Method Monday, they're so abstract or silly as to be completely useless. But today, I've come up with an example class that actually might have some use: a hashable integer.</p>
<div class="pygments_tango"><pre><span class="k">class</span> <span class="nc">HashableInt</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
    <span class="c"># An int with a non-colliding hash function   </span>
    <span class="n">hashvalue</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hashvalue</span> <span class="o">=</span> <span class="n">HashableInt</span><span class="o">.</span><span class="n">hashvalue</span>
        <span class="n">HashableInt</span><span class="o">.</span><span class="n">hashvalue</span> <span class="o">+=</span> <span class="mi">1</span>

<pre><code>&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__str__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hashable int &lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s"&gt; with hash &lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hashvalue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;HashableInt &lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s"&gt; with hash &lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s"&gt;&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hashvalue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__hash__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hashvalue&lt;/span&gt;
</code></pre>
<p></pre></div></p>
<p>Here's how this would play out:</p>
<p>$$code(lang=pythonconsole)</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = HashableInt(10)
str(x)
'Hashable int 10 with hash 0'
repr(x)
'<HashableInt 10 with hash 0>'
hash(x)
0
y = HashableInt(10)
hash(y)
1</p>
</blockquote>
</blockquote>
</blockquote>]]></content>
  </entry>
</feed>
